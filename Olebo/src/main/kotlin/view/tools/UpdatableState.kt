package jdr.exia.view.tools

import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.MutableState
import androidx.compose.runtime.remember
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.jetbrains.exposed.sql.Transaction

/**
 * Remember a state and update model when it changes.
 *
 * @param key1 A key used know when the recalculation needs to happen
 * @param key1 (Optional) A key used know when the recalculation needs to happen
 * @param calculation The calculation to remember. It should return a [MutableState]
 * @param onChange An action called each time the state changes. It is called in the IO thread and is a [Transaction].
 * @param onUpdated An action called when the model is successfully updated. It can be used to refresh the UI.
 * @return The [MutableState] generated by the calculation.
 */
@Composable
fun <T> rememberUpdatableState(
    key1: Any?,
    key2: Any? = null,
    calculation: () -> MutableState<T>,
    onChange: suspend (T) -> Unit,
    onUpdated: suspend () -> Unit = {}
): MutableState<T> {
    val initialValue = remember(key1 = key1, key2 = key2) { calculation().value }

    val state = remember(key1 = key1, key2 = key2, calculation)

    if (initialValue != state.value)
        LaunchedEffect(key1 = key1, key2 = key2, key3 = state.value) {
            withContext(Dispatchers.IO) {
                onChange(state.value)
            }

            onUpdated()
        }

    return state
}