package jdr.exia.view.tools

import androidx.compose.runtime.*
import kotlinx.coroutines.Dispatchers
import org.jetbrains.exposed.sql.Transaction
import org.jetbrains.exposed.sql.transactions.experimental.newSuspendedTransaction

/**
 * Remember a state and update model when it changes.
 *
 * @param key A key used know when the recalculation needs to happen
 * @param calculation The calculation to remember. It should return a [MutableState]
 * @param onChange An action called each time the state changes. It is called in the IO thread and is a [Transaction].
 * @param onUpdated An action called when the model is successfully updated. It can be used to refresh the UI.
 * @return The [MutableState] generated by the calculation.
 */
@Composable
inline fun <T> rememberUpdatableState(
    key: Any?,
    calculation: @DisallowComposableCalls () -> MutableState<T>,
    crossinline onChange: @DisallowComposableCalls suspend Transaction.(T) -> Unit,
    crossinline onUpdated: @DisallowComposableCalls suspend () -> Unit
): MutableState<T> {
    val state = remember(key1 = key, calculation)

    LaunchedEffect(key, state.value) {
        newSuspendedTransaction(Dispatchers.IO) {
            onChange(state.value)
        }

        onUpdated()
    }

    return state
}