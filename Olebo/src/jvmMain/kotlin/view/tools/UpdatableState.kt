package jdr.exia.view.tools

import androidx.compose.runtime.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.jetbrains.exposed.sql.Transaction

/**
 * Remember a state and update model when it changes.
 *
 * @param key1 A key used know when the recalculation needs to happen
 * @param key1 (Optional) A key used know when the recalculation needs to happen
 * @param calculation The calculation to remember. It should return a [MutableState]
 * @param onStateChange An action called each time the state changes. It is called in the IO thread and is a [Transaction].
 * @param onUpdated An action called when the model is successfully updated. It can be used to refresh the UI.
 * @return The [MutableState] generated by the calculation.
 */
@Composable
fun <T> rememberUpdatableState(
    key1: Any?,
    key2: Any? = null,
    evaluateInitialValue: () -> T,
    onStateChange: suspend (T) -> Unit,
    onUpdated: suspend () -> Unit = {}
): MutableState<T> {
    val scope = rememberCoroutineScope()

    val state = remember(key1, key2) {
        val state = mutableStateOf(evaluateInitialValue())

        object : MutableState<T> {
            override var value: T by state::value

            override fun component1(): T = state.component1()

            override fun component2(): (T) -> Unit = {
                state.component2().invoke(it)

                scope.launch {
                    withContext(Dispatchers.IO) {
                        onStateChange(state.value)
                    }

                    onUpdated()
                }
            }
        }
    }

    return state
}